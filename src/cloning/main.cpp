// Input to the executable: config.clone, config.cym
// Output to the executable: genealogy.clone, config.cym, directories with clones from each iteration

#include "cloning_params.h"
#include "cytosim_params.h"
#include "create_clones.h"
#include "cloning_calculations.h"
#include "interface.h"
#include "cloning_logistics.h"
#include "clone.h"
#include "iteration.h"

#include <string>
#include <cstdio>
#include <typeinfo>

#include <iostream> // std::cout

#ifdef _SINGULARITY_PATH
	#define SINGULARITY_PATH _SINGULARITY_PATH
#else
	//#define SINGULARITY_PATH "/software/singularity-3.4.0-el7-x86_64/bin/singularity" // type char
	#define SINGULARITY_PATH "/usr/bin/singularity"
#endif

#ifdef _CYTOSIM_CONTAINER_PATH
	#define CYTOSIM_CONTAINER_PATH _CYTOSIM_CONTAINER_PATH
#else
	// #define CYTOSIM_CONTAINER_PATH "/home/alexandral/cytosim_container/cytosim.sif"
	#define CYTOSIM_CONTAINER_PATH "/home/alexandra/temp/singularity/cytosim_container/cytosim.sif"
#endif

int main()
{
	std::cout << typeid(SINGULARITY_PATH).name() << std::endl ;
	std::cout << typeid(CYTOSIM_CONTAINER_PATH).name() << std::endl ;

	/* Set up cytosim interface through singularity
	 * interface.cpp, interface.h
	 */
	printf("Setting up interface with Singularity and Cytosim\n") ;

	// Declare interface struct
	Interface interface ;

	// Define strings with paths to singularity and cytosim singularity container
	// const std::string singularityPath = "/usr/bin/singularity" ;
	// const std::string cytosimContainerPath = "/home/alexandra/temp/singularity/cytosim_container/cytosim.sif" ;

	const std::string singularityPath = SINGULARITY_PATH ;
	const std::string cytosimContainerPath = CYTOSIM_CONTAINER_PATH ;

	std::cout << singularityPath << std::endl;
	std::cout << cytosimContainerPath << std::endl ;

	// Set interface path variables for later use
	set_interface(interface, singularityPath, cytosimContainerPath) ;

	/* Read input file specifying the parameters for cloning algo
	 * cloning_params.cpp, cloning_params.h
	 * cytosim_params.cpp, cytosim_params.h
	 */
	printf("Setting up cloning algorithm parameters\n") ;

	// Define the name of the cloning config file
	const std::string cloneConfigFileName = "config.clone" ;

	// Declare cloning struct and get params
	CloningParams cloningParams ;

	get_cloning_params(cloningParams, cloneConfigFileName) ;

	// Declare cytosim struct and get some params
	printf("Setting up Cytosim simulation parameters\n") ;

	CytosimParams cytosimParams ;

	get_cytosim_params(cytosimParams, cloneConfigFileName) ;
	calculate_num_time_steps_and_frames(cytosimParams, cloningParams) ;

	// generate config.cym that include the correct number of time steps and frames
	printf("Generating Cytosim config.cym file\n") ;

	gen_cytosim_config_file(cytosimParams) ;

	/* For each iteration of cloning algo, loop following functions
	 * iterator.cpp, iterator.h
	 */

	Iteration iteration ;

	// Doing the iterations and clones in a sloppy way for now - with for loops D:

	for (cloningParams.idxIter = 0 ; cloningParams.idxIter < cloningParams.numIters ; ++cloningParams.idxIter)
	{
		for (int cloneIdx = 0 ; cloneIdx < cloningParams.numClones ; ++cloneIdx)
		{
			/* Generate cytosim input files for each clone
			 * create_clones.cpp
			 */
			//create_empty_directories(cloningParams) ;

			/* For each clone, run cytosim simulation and calculate wDotIntegral: */

			// Create clone object to store relevant data for the clone
			Clone pastClone ;
			Clone clone ;

			/* Run iteration of simulation
			 * interface.cpp, interface.h
			 */
			printf("Running cytosim simulation\n") ;
			run_sim(interface) ;
			printf("Generating Cytosim report\n") ;
			run_report(interface) ;

			/* Calculate the value of the observable
			 * using the executable generated by files in /src/observable
			 * interface.cpp, interface.h
			 */
			printf("Calculating wDot for trajectory\n") ;
			calc_observable("calculate") ;

			// Read value of wDotIntegral from output file into clone data struct

			const std::string wDotIntFileName = "wDotIntegral.txt" ;

			// Increment the cloning iteration counter to account for completed
			// iteration.
			cloningParams.idxIter++ ;

			printf("Setting up Cloning calculations\n") ;
			// clone.cpp, clohe.h
			read_wDotIntegral(clone, wDotIntFileName) ;
			get_time_stamp(cloningParams, clone) ;

			// Calculate the s_a value for the individual clone
			calc_s_a(cloningParams, clone, pastClone) ;

			// Add the clone object to the clone object vector for the iteration
			iteration.cloneVector.push_back(clone) ;

			/* Generate cytosim "restart" files
			 * interface.cpp, interface.h
			 */
			// run_frametool(interface) ;

		}

		/* Perform the cloning operations that require values for all clones
		 * in the iteration
		 * cloning_calculations.cpp, cloning_calculations.h
		 */

		for (Clone & clone : iteration.cloneVector)
		{
			// Calculate the sum of values of s_a for all clones in the iteration
			sum_s_a(iteration, clone) ;



			// Calculate n_a, the number of duplicates for each clone
			calc_n_a(cloningParams, iteration, clone) ;

			// Add the number of duplicates for the clone to the genealogy vector
			iteration.genealogy.push_back(clone.numDuplicates) ;

		}

		printf("iteration.sumOfExponentials:\t\t%f\n", iteration.sumOfExponentials) ;

		/* Determine the logistics of copying
		 * cloning_logistics.cpp, cloning_logistics.h
		 */

		// Make sure the total number of clones matches the value specified in clone.config
		adjust_population(cloningParams, iteration) ;

		for (int num: iteration.genealogy)
		{
			std::cout << num << std::endl ;
		}

	}



}
